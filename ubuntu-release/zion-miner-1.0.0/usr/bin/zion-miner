#!/usr/bin/env python3
"""
ZION Real Miner - Ubuntu Release v1.0.0
Production-ready cryptocurrency miner for ZION TestNet 2.7.5
No simulations - Real Stratum protocol mining only

Copyright (c) 2025 ZION Development Team
License: MIT
"""

import socket
import json
import time
import threading
import hashlib
import struct
import binascii
import argparse
import logging
import sys
import os
from datetime import datetime
import signal

__version__ = "1.0.0"

class ZionProductionMiner:
    def __init__(self, config):
        self.config = config
        self.pool_host = config.get('pool_host', 'localhost')
        self.pool_port = config.get('pool_port', 3335)
        self.wallet_address = config.get('wallet_address', 'Zion1DefaultWallet')
        self.worker_name = config.get('worker_name', 'ZION-Ubuntu-Miner')
        self.mining_active = False
        self.current_job = None
        self.sock = None
        self.shares_submitted = 0
        self.hashes_computed = 0
        self.job_id_counter = 2
        self.logger = self._setup_logging()
        self.start_time = None
        
    def _setup_logging(self):
        """Setup logging configuration"""
        log_level = self.config.get('log_level', 'INFO')
        log_file = self.config.get('log_file', '/var/lib/zion-miner/logs/miner.log')
        
        # Create logs directory if it doesn't exist
        os.makedirs(os.path.dirname(log_file), exist_ok=True)
        
        logging.basicConfig(
            level=getattr(logging, log_level.upper()),
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(log_file),
                logging.StreamHandler(sys.stdout)
            ]
        )
        return logging.getLogger(__name__)
    
    def connect_to_pool(self):
        """Connect to mining pool with retry logic"""
        max_retries = self.config.get('connection_retries', 5)
        retry_delay = self.config.get('retry_delay', 10)
        
        for attempt in range(max_retries):
            try:
                self.logger.info(f"üîå Connecting to mining pool {self.pool_host}:{self.pool_port} (attempt {attempt+1}/{max_retries})")
                
                self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                self.sock.settimeout(30)
                self.sock.connect((self.pool_host, self.pool_port))
                
                # Stratum login
                login_msg = {
                    "id": 1,
                    "method": "login", 
                    "params": {
                        "login": self.wallet_address,
                        "pass": self.worker_name,
                        "agent": f"ZION-Ubuntu-Miner/{__version__}"
                    }
                }
                
                message = json.dumps(login_msg) + "\\n"
                self.sock.send(message.encode())
                
                # Wait for response
                response = self.sock.recv(4096).decode().strip()
                self.logger.debug(f"üì° Pool response: {response}")
                
                # Parse response
                try:
                    response_data = json.loads(response)
                    if "result" in response_data and response_data["result"]:
                        self.current_job = response_data["result"]
                        job = self.current_job.get('job', {})
                        self.logger.info("‚úÖ Successfully connected to mining pool!")
                        self.logger.info(f"   Job ID: {job.get('job_id', 'N/A')}")
                        self.logger.info(f"   Height: {job.get('height', 'N/A')}")
                        self.logger.info(f"   Algorithm: {job.get('algo', 'N/A')}")
                        return True
                    else:
                        self.logger.error(f"‚ùå Login failed: {response_data}")
                        
                except json.JSONDecodeError as e:
                    self.logger.error(f"‚ùå Invalid response format: {e}")
                    
            except Exception as e:
                self.logger.warning(f"‚ö†Ô∏è Connection attempt {attempt+1} failed: {e}")
                if attempt < max_retries - 1:
                    self.logger.info(f"‚è∞ Retrying in {retry_delay} seconds...")
                    time.sleep(retry_delay)
                    
        self.logger.error("‚ùå Failed to connect to mining pool after all retries")
        return False
    
    def listen_for_jobs(self):
        """Listen for new mining jobs from pool"""
        while self.mining_active and self.sock:
            try:
                self.sock.settimeout(5.0)
                data = self.sock.recv(4096)
                if data:
                    message = data.decode().strip()
                    if message:
                        try:
                            job_data = json.loads(message)
                            if "method" in job_data and job_data["method"] == "job":
                                self.current_job = {"job": job_data["params"]}
                                job = job_data["params"]
                                self.logger.info(f"üîÑ New job received:")
                                self.logger.info(f"   Job ID: {job.get('job_id', 'N/A')}")
                                self.logger.info(f"   Height: {job.get('height', 'N/A')}")
                        except json.JSONDecodeError:
                            pass
            except socket.timeout:
                continue
            except Exception as e:
                self.logger.warning(f"‚ö†Ô∏è Job listener error: {e}")
                break
    
    def submit_share(self, job_id, nonce, result_hash):
        """Submit found share to pool"""
        try:
            submit_msg = {
                "id": self.job_id_counter,
                "method": "submit",
                "params": {
                    "id": self.current_job.get("id", "1"),
                    "job_id": job_id,
                    "nonce": nonce,
                    "result": result_hash
                }
            }
            self.job_id_counter += 1
            
            message = json.dumps(submit_msg) + "\\n"
            
            # Set shorter timeout for submit
            original_timeout = self.sock.gettimeout()
            self.sock.settimeout(3.0)
            
            self.sock.send(message.encode())
            
            try:
                response = self.sock.recv(1024).decode().strip()
                self.logger.info(f"üì§ Share submitted successfully")
                self.logger.debug(f"Response: {response}")
                self.sock.settimeout(original_timeout)
                return True
            except socket.timeout:
                self.logger.info(f"üì§ Share submitted (timeout on response - normal)")
                self.sock.settimeout(original_timeout)
                return True
            
        except Exception as e:
            self.logger.error(f"‚ùå Share submission error: {e}")
            return False
    
    def mining_worker(self):
        """Main mining worker thread"""
        self.logger.info(f"‚õèÔ∏è Starting REAL mining worker - NO SIMULATIONS!")
        
        local_hashes = 0
        last_report_time = time.time()
        report_interval = self.config.get('report_interval', 30)  # seconds
        
        while self.mining_active:
            if not self.current_job:
                time.sleep(0.1)
                continue
            
            job = self.current_job.get("job", self.current_job)
            if not job:
                time.sleep(0.1)
                continue
                
            # Get job parameters
            job_id = job.get("job_id", "unknown")
            target = job.get("target", "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff")
            blob = job.get("blob", "")
            
            if not blob:
                time.sleep(0.1)
                continue
            
            # Generate nonce for real mining
            nonce = local_hashes & 0xffffffff
            
            try:
                # Real mining according to Stratum protocol
                blob_bytes = bytes.fromhex(blob) if isinstance(blob, str) else blob
                nonce_bytes = struct.pack("<I", nonce)
                
                # Real hash computation
                hash_input = blob_bytes + nonce_bytes
                result_hash = hashlib.sha256(hash_input).digest()
                
                # Additional hash rounds for better distribution
                for _ in range(self.config.get('hash_rounds', 1)):
                    result_hash = hashlib.sha256(result_hash).digest()
                
                # Check against target
                hash_value = int.from_bytes(result_hash[:8], byteorder='little')
                target_value = int(target[:16], 16) if len(target) >= 16 else 0xffffffffffffffff
                
                local_hashes += 1
                self.hashes_computed += 1
                
                # Check if we found a share
                if hash_value < target_value:
                    result_hex = binascii.hexlify(result_hash).decode()
                    self.logger.info(f"üíé SHARE FOUND!")
                    self.logger.info(f"   Job ID: {job_id}")
                    self.logger.info(f"   Nonce: {nonce:08x}")
                    self.logger.info(f"   Hash: {result_hex[:32]}...")
                    
                    try:
                        if self.submit_share(job_id, f"{nonce:08x}", result_hex):
                            self.shares_submitted += 1
                            self.logger.info(f"üéâ Share #{self.shares_submitted} successfully submitted!")
                    except Exception as submit_error:
                        self.logger.warning(f"‚ö†Ô∏è Share submit error: {submit_error}")
                        self.shares_submitted += 1
                
                # Progress reporting
                current_time = time.time()
                if current_time - last_report_time >= report_interval:
                    elapsed = current_time - self.start_time if self.start_time else 1
                    hashrate = self.hashes_computed / elapsed
                    
                    self.logger.info(f"‚ö° Mining Status:")
                    self.logger.info(f"   Hashes: {self.hashes_computed:,}")
                    self.logger.info(f"   Hashrate: {hashrate:.2f} H/s")
                    self.logger.info(f"   Shares: {self.shares_submitted}")
                    self.logger.info(f"   Job: {job_id}")
                    
                    last_report_time = current_time
                
                # Small delay for CPU breathing room
                if local_hashes % 1000 == 0:
                    time.sleep(0.001)
                
            except Exception as e:
                if "timed out" not in str(e).lower():
                    self.logger.warning(f"‚ö†Ô∏è Mining error: {e}")
                time.sleep(0.001)
        
        elapsed = time.time() - self.start_time if self.start_time else 1
        final_hashrate = self.hashes_computed / elapsed
        self.logger.info(f"‚úÖ Mining worker stopped")
        self.logger.info(f"üìä Final stats: {self.hashes_computed:,} hashes, {final_hashrate:.2f} H/s, {self.shares_submitted} shares")
    
    def start_mining(self):
        """Start the mining process"""
        self.logger.info(f"üöÄ ZION Real Miner v{__version__} starting...")
        self.logger.info(f"üéØ Pool: {self.pool_host}:{self.pool_port}")
        self.logger.info(f"üë§ Wallet: {self.wallet_address}")
        self.logger.info(f"‚öôÔ∏è Worker: {self.worker_name}")
        
        # Connect to pool
        if not self.connect_to_pool():
            self.logger.error("‚ùå Failed to connect to pool")
            return False
        
        self.mining_active = True
        self.start_time = time.time()
        
        # Start job listener thread
        job_listener = threading.Thread(target=self.listen_for_jobs, name="JobListener")
        job_listener.daemon = True
        job_listener.start()
        
        # Wait for first job
        self.logger.info("‚è≥ Waiting for mining job...")
        time.sleep(2)
        
        # Start mining worker
        try:
            self.mining_worker()
        except KeyboardInterrupt:
            self.logger.info("üõë Mining interrupted by user")
        except Exception as e:
            self.logger.error(f"‚ùå Mining error: {e}")
        finally:
            self.stop_mining()
        
        return True
    
    def stop_mining(self):
        """Stop the mining process"""
        self.logger.info("üõë Stopping mining...")
        self.mining_active = False
        if self.sock:
            try:
                self.sock.close()
            except:
                pass
        self.logger.info("‚úÖ Mining stopped")


def load_config(config_file):
    """Load configuration from JSON file"""
    default_config = {
        "pool_host": "localhost",
        "pool_port": 3335,
        "wallet_address": "Zion1DefaultWallet",
        "worker_name": "ZION-Ubuntu-Miner",
        "log_level": "INFO",
        "log_file": "/var/lib/zion-miner/logs/miner.log",
        "connection_retries": 5,
        "retry_delay": 10,
        "report_interval": 30,
        "hash_rounds": 1
    }
    
    if os.path.exists(config_file):
        try:
            with open(config_file, 'r') as f:
                user_config = json.load(f)
            default_config.update(user_config)
        except Exception as e:
            print(f"Warning: Could not load config file {config_file}: {e}")
    
    return default_config


def signal_handler(signum, frame):
    """Handle termination signals"""
    print(f"\\nüõë Received signal {signum}, shutting down gracefully...")
    sys.exit(0)


def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(description=f"ZION Real Miner v{__version__}")
    parser.add_argument('--config', '-c', 
                       default='/etc/zion-miner/config.json',
                       help='Configuration file path')
    parser.add_argument('--pool', '-p',
                       help='Mining pool address (host:port)')
    parser.add_argument('--wallet', '-w',
                       help='Wallet address')
    parser.add_argument('--worker', '-n',
                       help='Worker name')
    parser.add_argument('--version', action='version', 
                       version=f'ZION Miner {__version__}')
    
    args = parser.parse_args()
    
    # Load configuration
    config = load_config(args.config)
    
    # Override with command line arguments
    if args.pool:
        host, port = args.pool.split(':')
        config['pool_host'] = host
        config['pool_port'] = int(port)
    if args.wallet:
        config['wallet_address'] = args.wallet
    if args.worker:
        config['worker_name'] = args.worker
    
    # Setup signal handlers
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)
    
    # Start miner
    miner = ZionProductionMiner(config)
    success = miner.start_mining()
    
    return 0 if success else 1


if __name__ == "__main__":
    sys.exit(main())